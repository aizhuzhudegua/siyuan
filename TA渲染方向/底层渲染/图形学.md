# 图形学

![img](assets/v2-3a9f850c46ad6c4a750edab74141bd4a_720w-20250209174821-ymw5by8.webp)

# 一、Transformation

- ## Model

  ![image-20240325193619907](assets/image-20240325193619907-20250209174821-fkgf0qo.png)

  ## 相机空间

  看向-z，对于相机空间来说，所有物体在-z
- ## MVP矩阵

  ### Camera Transformation

  我们要将三维世界的摄像机归于原点，于是我们把摄像机和所有物体都做一次视图变换

  1. 平移到原点
  2. 旋转

      $$
      M_{view}=R_{view}T_{view}
      $$

  这其中旋转矩阵的逆好写：

  $$
  我们原本是令 g（lookat） 朝向-Z，t（top）朝向Y，g \times t 朝向X\\而现在R^{-1}_{view}是让Z朝向-g，Y朝向t，X朝向g,很容易写出：\\
  R^{-1}_{view}=\left\{\begin{matrix}
     x_{\widehat{g}\times \widehat{t}} & x_t & x_{-g} & 0\\
     y_{\widehat{g}\times \widehat{t}} & y_t & y_{-g} & 0\\
     z_{\widehat{g}\times \widehat{t}} & z_t & z_{-g} & 0\\
     0 & 0 & 0 & 1
    \end{matrix}\right\} \\
    将XYZ带入发现确实发生了上述变换\\
    \because 所有的变换矩阵都是正交矩阵\\
    \therefore R^{T}_{view}=R^{-1}_{view},R_{view}=(R^{-1}_{view})^{T}
  $$

  最后为什么乘上这样一个令向量旋转的矩阵能够让所有坐标绕原点旋转，我认为向量和坐标都能够旋转，只不过向量不能平移，而矩阵中都是单位向量，能够保存坐标到原点这个向量的大小

  $$
  e\cdot b = |b|\sin\Theta
  $$

# 二、Projection

做这一步的时候视角已经看向-z ，摄像机位于原点

投影变换之后w的值是原来的z值

## 视锥的两个属性：

1、fovY

2、Aspect ratio（width/height）

![image-20240326194856875](assets/image-20240326194856875-20250209174821-18jb0xc.png)

![image-20240326195941687](assets/image-20240326195941687-20250209174821-kz0oqie.png)

## Persp->otho

相似三角形

![image-20240326201958267](assets/image-20240326201958267-20250209174821-dicxcaa.png)

![image-20240326202927121](assets/image-20240326202927121-20250209174821-sz23xzm.png)

![image-20240326203135215](assets/image-20240326203135215-20250209174821-h9dd4k1.png)

![image-20240326203404455](assets/image-20240326203404455-20250209174821-q2i1df3.png)

原则1：近平面上的点永远会映射为他自己

![image-20240326204431348](assets/image-20240326204431348-20250209174821-ivjufnc.png)

给定z=n，可以得出unkown值为n²，第三行与x，y无关

![image-20240326204738905](assets/image-20240326204738905-20250209174821-og485cd.png)

原则2：远平面中心点不变

![image-20240326205140627](assets/image-20240326205140627-20250209174821-6lzk1gy.png)

![image-20240326205859749](assets/image-20240326205859749-20250209174821-foxscff.png)

## 正交投影

结果是一个Canonical cube（标准立方体）

![image-20240327074752665](assets/image-20240327074752665-20250209174821-d30pwfx.png)

![image-20240327075219947](assets/image-20240327075219947-20250209174821-uojgiar.png)

## **裁剪空间 → NDC 空间（核心步骤）**

对裁剪空间的齐次坐标执行**透视除法**：

## 视口空间（view port）

视口变换的结果是xy被映射到了0-1的范围，而z值直接取自相机空间的z值取-z （由于相机空间的物体都是负数的z），表示与相机的距离

## 屏幕空间

![image-20240326201009856](assets/image-20240326201009856-20250209174821-n1wk1lq.png)

把标准立方体的x，y与屏幕坐标对齐

![image-20240327151054852](assets/image-20240327151054852-20250209174821-x73gkyn.png)

# 三、光栅化

## 采样

![image-20240327152329772](assets/image-20240327152329772-20250209174821-1ldkl9s.png)

![image-20240304105433715](assets/image-20240304105433715-20250209174821-msqhs0p.png)

## 边界盒

![image-20240305143350389](assets/image-20240305143350389-20250209174821-iyruzbd.png)

## 采样的几种瑕疵（Artifacts）

- 锯齿
- 摩尔纹
- 车轮效应

根本原因：函数（信号）的变化太快以至于采样的速度跟不上

措施：

- 模糊

![image-20240305150426659](assets/image-20240305150426659-20250209174821-v1ykhiv.png)

### 为什么？

Frequency Domain

高通滤波，低通滤波

滤波 = 平均 = 卷积

**滤波是一种低通滤波**

### 超级采样（MSAA）4x

![image-20240305164333946](assets/image-20240305164333946-20250209174821-6l5azzm.png)

超级采样把一个像素划分为4*4个像素，每个像素有一个中心点，把被三角形覆盖的像素取一个平均值

### 快速近似抗锯齿(FXAA)

### 时间性抗锯齿(TAA)

### 超分辨率(DLSS)

## Z-Buffer

这块要结合重心坐标

![在这里插入图片描述](assets/8ce765c15da94ec6a0b70bdfd4a9edc1-20250209174822-ml71kwk.png)

透视校正是通过除以齐次坐标中的w分量的倒数来完成的。在图形渲染中，顶点坐标通常是以齐次坐标形式表示的（x, y, z, w），其中w分量表示透视信息。在透视投影后，深度值（z）会与w分量相关联，即深度值需要除以w分量才能得到正确的结果。

```c++
float w_reciprocal = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());
float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();
z_interpolated *= w_reciprocal;
```

# 四、Shading

shading要使用相机空间的坐标

着色频率有三个等级：面、顶点、片元（像素）

## 布林冯模型（phong模型的改进）

### diffuse reflection

均匀的反射，所有与v无关

![image-20240312202105409](assets/image-20240312202105409-20250209174822-wodz39a.png)

![image-20240312202634521](assets/image-20240312202634521-20250209174822-jrgzj7m.png)

![image-20240312202517248](assets/image-20240312202517248-20250209174822-rrggtl3.png)

光在球壳上的衰减

![image-20240312202941852](assets/image-20240312202941852-20250209174822-lledk6f.png)

推导：

![image-20240312203756462](assets/image-20240312203756462-20250209174822-0c6xi27.png)

![image-20240312204019244](assets/image-20240312204019244-20250209174822-zrz3qgq.png)

kd = 1 时反射所有光，等于0时吸收所有光

### Specular reflection

![image-20240313144413154](assets/image-20240313144413154-20250209174822-17pnq6a.png)

布林冯模型将R与v的接近关系转换为半程向量h=（l+v）/|l+v| 与法向量n的接近程度

![image-20240313144534619](assets/image-20240313144534619-20250209174822-jk54kj1.png)

![image-20240313144852767](assets/image-20240313144852767-20250209174822-p2tkhhc.png)

从图像可以知道p预示着高光的衰减速度

![image-20240313145234901](assets/image-20240313145234901-20250209174822-h7ojr2v.png)

### Ambient

![image-20240313145707033](assets/image-20240313145707033-20250209174822-1bi8osa.png)

![img](assets/dfcfd618994843f58a275d8d695c2f19-20250209174822-iian38t.png)

# 实时渲染管线

![image-20240315141528745](assets/image-20240315141528745-20250209174822-dlmhmly.png)

着色可以发生在 ：

**vertex processing：** 顶点级着色

**fragment processing：** 像素级着色 （opengl）

# 三、纹理

## 重心坐标（Barycentric Coordinates）

这个公式说明了A,B,C三个点对（x，y）的影响程度

$$
\alpha,\beta,\gamma,说明的是三个点对(x,y)的影响程度，因此他们的和是1
$$

由此可以大胆推断四边形，五边形也是同理

![image-20240515103947827](assets/image-20240515103947827-20250209174822-lho584y.png)

![image-20240319162025418](assets/image-20240319162025418-20250209174822-t629bpd.png)

如何求重心坐标

![image-20240319162857654](assets/image-20240319162857654-20250209174822-zqua18v.png)

![image-20240515195115273](assets/image-20240515195115273-20250209174822-no2nuem.png)

![image-20240319163059426](assets/image-20240319163059426-20250209174822-v7timkm.png)

## 纹理分辨率太小了的解决措施

![image-20240319195449413](assets/image-20240319195449413-20250209174822-l4pirw6.png)

### 双线性插值（Bilinear interpolation）

![image-20240319195021936](assets/image-20240319195021936-20250209174822-ysh6u7z.png)

## 纹理分辨率太大了呢

### 反走样技术：超级采样等

### Mipmap（计算机视觉里叫他图像金字塔）

额外存储只是1/3 ，为什么？

![image-20240319202545574](assets/image-20240319202545574-20250209174822-5ynze0b.png)

把每一层的图x3 ，最后可以摆成如下：

![image-20240319204310569](assets/image-20240319204310569-20250209174822-1jn8xw4.png)

三个是第一层，第四个是其他层的组合

mipmap并不是连续的层，层与层之间是用插值解决的，这种处理导致远处 模糊

### 各向异性过滤

![image-20240320101722958](assets/image-20240320101722958-20250209174822-g3jy010.png)

## 凹凸贴图 (bump)

![image-20240402141912072](assets/image-20240402141912072-20250209174822-rqhv2ya.png)

c 是影响因子，按理说会有一个误差项，但误差项应该融入到c里边去了

![image-20240520150753535](assets/image-20240520150753535-20250209174822-rxo15gu.png)

### TBN矩阵

作业3用了简单的TBN，并不是这个

![image-20240521162005768](assets/image-20240521162005768-20250209174822-6ydhrrh.png)

具体实施的时候只需利用[t b n]向量组成的矩阵乘以法线贴图上的存储3维信息，即可得到正确的法线向量了

理解成线性空间的转换：

![image-20240520192418677](assets/image-20240520192418677-20250209174822-shuu0yp.png)

作业3是转变为view space的坐标

## 位移贴图(displacement)

# 几何

## 显示表出

### 1、几何面

### 2、参数映射

![image-20240402145359168](assets/image-20240402145359168-20250209174822-m6g3h33.png)

### 3、点云

### 4、贝塞尔曲线

![image-20240402164035490](assets/image-20240402164035490-20250209174822-nd1os8d.png)

#### 公式

![image-20240408083517803](assets/image-20240408083517803-20250209174822-sbgg999.png)

#### 递归实现

```c++
 cv::Point2f recursive_bezier(const std::vector<cv::Point2f> &control_points, float t)   
	// 法一：点加向量百分比
    if (control_points.size() != 1)
    {
        std::vector<cv::Point2f> gen_control_points;
        for (int i = 1; i < control_points.size(); i++)
        {
            cv::Point2f v = control_points[i]-control_points[i-1];
            gen_control_points.emplace_back(control_points[i-1]+v*t);
        }
        return recursive_bezier(gen_control_points,t);
    }
    return control_points[0];
}
```

```c++
 cv::Point2f recursive_bezier(const std::vector<cv::Point2f> &control_points, float t)   
	// 法二：插值
    int len = control_points.size();
    if (len == 1)
        return control_points[0];
    std::vector<cv::Point2f> lerp_control_points(len - 1, cv::Point2f(0.0, 0.0));
    for (int i = 0; i < len - 1; ++i)
    {
        lerp_control_points[i] = t * control_points[i] + (1 - t) * control_points[i + 1];
    }
    return recursive_bezier(lerp_control_points, t);
}
```

重要性质：

1、对贝塞尔曲线做仿射变换等价于对控制点做仿射变换

2、凸包性质，贝塞尔曲线不会超过控制点形成的凸包（橡皮筋）

![image-20240403092831101](assets/image-20240403092831101-20250209174822-x0ly8ld.png)

5、逐段的贝塞尔曲线（更好控制形状）

三次贝塞尔曲线，四个控制点

ps的钢笔工具

![image-20240403093720514](assets/image-20240403093720514-20250209174822-fig1n58.png)

6、b样条（B-splines）

7、NURBS

8、曲面

四条贝塞尔曲线的点作为控制点再做贝塞尔曲线

![image-20240408083918259](assets/image-20240408083918259-20250209174822-w9f6gco.png)

他是一种参数映射：

![image-20240408084353480](assets/image-20240408084353480-20250209174822-9wonub3.png)

## 隐式表出

公式

距离函数

分型

### 网格操作

![image-20240408084732381](assets/image-20240408084732381-20250209174822-i582gq9.png)

#### 曲面细分

#### Loop Subdivision

更新顶点的方式

![image-20240409083517498](assets/image-20240409083517498-20250209174822-h9u0lx6.png)

![image-20240409083621582](assets/image-20240409083621582-20250209174822-osz0kuo.png)

#### Catmull-Clark Subdivision

![image-20240409091754381](assets/image-20240409091754381-20250209174822-0c2z5ou.png)

![image-20240409092809112](assets/image-20240409092809112-20250209174822-slocblh.png)

#### Simplification

#### Quadric Error Mesh Simplification

# 阴影

点光源：Shadow  Map

1、从光源看向场景，记录深度图

2、从相机视角判断看到的点的深度是否和深度图相同

存在的问题：

1、Shadow  Map的分辨率问题

2、浮点数精度问题

# 光线追踪

## 实现步骤

逆光栅化

![image-20240607083051799](assets/image-20240607083051799-20250209174822-1qd1hgk.png)

1、raster space -> NDC space

![image-20240606191713272](assets/image-20240606191713272-20250209174822-w9s8kbf.png)

2、NDC space->screen  space

![image-20240606191658901](assets/image-20240606191658901-20250209174822-sb66w3d.png)

3、screen  space->world space

AB一般为1

![image-20240606194050041](assets/image-20240606194050041-20250209174822-qd8hrqm.png)

光路的可逆性

![image-20240409191507258](assets/image-20240409191507258-20250209174822-7nhzg1s.png)

![image-20240409192853849](assets/image-20240409192853849-20250209174822-k5vy1i7.png)

## Ray-Surface Intersection（光线求交）

光线定义

![image-20240409193331928](assets/image-20240409193331928-20250209174822-cymync3.png)

o是光源位置，d是光线方向，这个等式可以描绘光线上的任意一点

![image-20240410094205271](assets/image-20240410094205271-20250209174822-6hri89y.png)

### 隐式表面求交：

与球的交点：

![image-20240410094228533](assets/image-20240410094228533-20250209174822-wfx9nh3.png)

![image-20240410094138960](assets/image-20240410094138960-20250209174822-z1fefuk.png)

![image-20240410094749836](assets/image-20240410094749836-20250209174822-jlvuzru.png)

![image-20240410094859666](assets/image-20240410094859666-20250209174822-7ab5bje.png)

对于一般性的隐式表面 ，把公式带入f

![image-20240410095237494](assets/image-20240410095237494-20250209174822-u512yen.png)

### 显式表面求交：

平面定义：

给定一个点p prime和一个法向量N可以确定一个平面

![image-20240410102939512](assets/image-20240410102939512-20250209174822-cl8wgqy.png)

将光线与三角形的交点转换成光线与平面的交点，再判断交点在不在三角形内

![image-20240410103222066](assets/image-20240410103222066-20250209174822-02wyfrt.png)

#### 通过重心坐标判一次性求交（**Möller-Trumbore**算法）：

![image-20240410104405772](assets/image-20240410104405772-20250209174822-5evo95t.png)

推导过程

![image-20240606113755563](assets/image-20240606113755563-20250209174822-wh9ami1.png)

1-b1-12 , b1 , b2都为正则说明光线在三角形内

#### 加速措施：包围盒

轴对齐包围盒

![image-20240410110121708](assets/image-20240410110121708-20250209174822-itodpb7.png)

2d的情况下，两个对面

![image-20240410140824574](assets/image-20240410140824574-20250209174822-bugl0pw.png)

3d情况下：

光线在进入所有对面时才算进入盒子

光线离开任意一个对面就已经离开盒子

```c++
float tEnter = std::max(vec_tEnter.x, std::max(vec_tEnter.y, vec_tEnter.z));
float tExit = std::min(vec_tExit.x, std::min(vec_tExit.y, vec_tExit.z));

```

![image-20240410141302924](assets/image-20240410141302924-20250209174822-6n3qk85.png)

![image-20240410145416226](assets/image-20240410145416226-20250209174822-eiwxe38.png)

```c++
if (tEnter <  tExit && tExit >= 0)
        return true;
    else
        return false;
```

轴对齐简化了计算：

![image-20240410151316998](assets/image-20240410151316998-20250209174822-t0rc96r.png)

#### 如何用包围盒加速

![image-20240410194136048](assets/image-20240410194136048-20250209174822-eh9qkcl.png)

##### KD-Tree

根据xyz交替划分

![image-20240410195131656](assets/image-20240410195131656-20250209174822-hxyqam5.png)

求交

![image-20240410195859297](assets/image-20240410195859297-20250209174822-2u3exrt.png)

存在问题：物体与包围盒的交集很难划分

### Bounding Volume Hierarchy（BVH）基于物体的划分

1、总是选择最长轴划分

2、划分时保证两边三角形数量差不多

##### 快速划分算法

##### 先序遍历划分树

![image-20240410210629821](assets/image-20240410210629821-20250209174822-8mii3vt.png)

#### Basic radiometry(辐射度量学)

![image-20240411150511748](assets/image-20240411150511748-20250209174822-vcbyf4g.png)

###### 立体角的定义

![image-20240411151659964](assets/image-20240411151659964-20250209174822-8s6zwbh.png)

![image-20240412173924436](assets/image-20240412173924436-20250209174822-xfrcvy3.png)

立体角

![image-20240414205626043](assets/image-20240414205626043-20250209174822-ipw4ucx.png)

Intensity（假设各个角度上都是均匀的）

与I无关

$$
\Phi=I\int\nolimits_{S^2} d\omega；方向角对球面的积分就是4\pi
$$

![image-20240414211654118](assets/image-20240414211654118-20250209174822-0o4z8k2.png)

Irradiance

定义和单位：单位面积收到的能量

![image-20240415083019538](assets/image-20240415083019538-20250209174822-oc3qft7.png)

与Lambert‘s Cosine Law关联

![image-20240415083807491](assets/image-20240415083807491-20250209174822-0dpg79h.png)

![image-20240415084531704](assets/image-20240415084531704-20250209174822-h38s3j4.png)

**Radiance**

dA cos代表投影的面积

Radiance也就是单位立体角辐射出的能量在投影上的单位面积能量

![image-20240415091741326](assets/image-20240415091741326-20250209174822-85tfy5g.png)

![image-20240415094511846](assets/image-20240415094511846-20250209174822-r7p259y.png)

##### BRDF

描述光线和物体如何作用 材质

![image-20240424174420327](assets/image-20240424174420327-20250209174822-e2qn903.png)

![image-20240424174144585](assets/image-20240424174144585-20250209174822-3a45rr4.png)

![image-20240424174400816](assets/image-20240424174400816-20250209174822-yhqiy6b.png)

考虑物体自身发光情况

![image-20240424191209853](assets/image-20240424191209853-20250209174822-rd1iy9b.png)

简写

![image-20240424194048211](assets/image-20240424194048211-20250209174822-yz0kgfs.png)

# 概率论部分

## 离散型的期望

期望是一种平均值，如3.5是投无数次骰子得到的平均点数

![image-20240424195816583](assets/image-20240424195816583-20250209174822-2xgaau4.png)

## 连续型的期望

连续的概率用概率密度函数定义，即 p(x)dx 是一点处的概率

![image-20240424200541381](assets/image-20240424200541381-20250209174822-tnkxp2l.png)

![image-20240424205720888](assets/image-20240424205720888-20250209174822-4u0pvph.png)

## Monte Carlo Integration

![image-20240507195755561](assets/image-20240507195755561-20250209174822-ip1gk3e.png)

用蒙特卡洛方法解渲染方程

![image-20240508085053045](assets/image-20240508085053045-20250209174822-09t6oof.png)

一个半球上的立体角是2Π，因此各个立体角上的pdf是 1/2Π（采用均匀采样）

![image-20240508084702350](assets/image-20240508084702350-20250209174822-1xho0la.png)

伪代码

![image-20240508085303851](assets/image-20240508085303851-20250209174822-t78by3i.png)

考虑到全局光

![image-20240508085949121](assets/image-20240508085949121-20250209174822-269dvk1.png)

采用一根光线，n=1的路径追踪

![image-20240508144819743](assets/image-20240508144819743-20250209174822-5rkrsor.png)

### 关于光线弹射几次的问题

![image-20240508151850289](assets/image-20240508151850289-20250209174822-uhuhkvp.png)

### 直接光照加间接光照的做法

![image-20240508160326916](assets/image-20240508160326916-20250209174822-zosf4lq.png)

### 考虑光源是否被遮挡

![image-20240508160654979](assets/image-20240508160654979-20250209174822-9ox4uvv.png)

# 材质

![image-20240618195947474](assets/image-20240618195947474-20250209174822-pcd5vjr.png)

![image-20240618201050620](assets/image-20240618201050620-20250209174822-k7s19uk.png)

![image-20240618202133066](assets/image-20240618202133066-20250209174822-rszjtet.png)

![image-20240618202908021](assets/image-20240618202908021-20250209174822-1jvlrj5.png)

![image-20240618203539711](assets/image-20240618203539711-20250209174822-p3ddmhe.png)

## 微表面模型

![image-20240620195206718](assets/image-20240620195206718-20250209174822-ely80gu.png)

# 动画

## 质点弹簧系统

### 胡克定律

考虑摩擦力

![image-20240621150641090](assets/image-20240621150641090-20250209174822-fcpcenz.png)

考虑弹簧长度

![image-20240702110434152](assets/image-20240702110434152-20250209174822-m734yyy.png)

## 粒子系统

![image-20240621152554497](assets/image-20240621152554497-20250209174822-st708wh.png)

### 单粒子模拟（Single Particle Simulation）

欧拉方法

![image-20240702110841872](assets/image-20240702110841872-20250209174822-9wfmer1.png)

```c++
// TODO (Part 2): Add the force due to gravity, then compute the new velocity and position
// a = F/m
// For implicit method 
// auto a = m->forces / m->mass + gravity;
// m->position += m->velocity * delta_t; // For explicit method
// m->velocity += a * delta_t; 

// For semi-implicit method  
auto a = m->forces / m->mass + gravity- kd * m->velocity / m->mass;     
m->velocity += a * delta_t; 
m->position += m->velocity * delta_t;   
// TODO (Part 2): Add global damping
```

verlet方法

![image-20240702111039234](assets/image-20240702111039234-20250209174822-2uasi4o.png)

```c++
float damping_factor = 0.00005;
Vector2D temp_position = m->position;
auto a = m->forces / m->mass + gravity;
// TODO (Part 3.1): Set the new position of the rope mass
m->position = temp_position + (1 - damping_factor) * (temp_position - m->last_position) + a * delta_t * delta_t;
m->last_position = temp_position; 
```

## 基于物理的动画

![image-20240702195729359](assets/image-20240702195729359-20250209174823-0z3mgh6.png)

# 完全自己造轮子的项目

https://github.com/ssloy/tinyrenderer

https://github.com/ssloy/tinyrenderer/wiki

# 作业0

乌班图部署

https://blog.csdn.net/weixin_51703174/article/details/117701754

‍
