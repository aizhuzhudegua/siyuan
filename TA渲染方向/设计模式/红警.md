# 红警

# 总类图

![设计模式 - 红色警戒](assets/设计模式%20-%20红色警戒-20250209153706-tym6sea.png)

# 脚本和游戏物体分离的模式

## 优点

- 场景结构清晰
- 通用性

## 缺点

- 不利于维护

# 函数

```c#
DontDestroyOnLoad(this.gameObject);
```

# 状态模式

![image-20241122151541960](assets/image-20241122151541960-20250209153706-mbobrj4.png)

![image-20241122152040119](assets/image-20241122152040119-20250209153706-npndyhn.png)

## code

```c#
public class DM01State : MonoBehaviour
{
    private void Start()
    {
        Context context = new Context();
        // 设置默认状态 
        context.SetState(new ConcreteStateA(context));
        
        context.Handle(5);
        context.Handle(20);
        context.Handle(20);
    }
}

public class Context
{
    private IState mState;
    public void SetState(IState state)
    {
        mState = state; 
    }

    public void Handle(int arg)
    {
        mState.Handle(arg);
    }
}

public interface IState
{
    void Handle(int arg);
}

public class ConcreteStateA : IState
{
    private Context mContext;
    public ConcreteStateA(Context context)
    {
        mContext = context;
    }
    public void Handle(int arg)
    {
        Debug.Log("Concret StateA " + arg);
        // 状态转换
        if(arg > 10)
        {
            mContext.SetState(new ConcreteStateB(mContext));
        }
    }
}

public class ConcreteStateB : IState
{
    private Context mContext;
    public ConcreteStateB(Context context)
    {
        mContext = context;
    }
    public void Handle(int arg)
    {
        Debug.Log("Concret StateB " + arg);
        // 状态转换
        if (arg <= 10)
        {
            mContext.SetState(new ConcreteStateA(mContext));
        }
    }
}
```

# 场景管理

![image-20241122213417040](assets/image-20241122213417040-20250209153706-zmmxoja.png)

![image-20241122211856732](assets/image-20241122211856732-20250209153706-p15ygeo.png)

```c#
AsyncOperation mAO = SceneManager.LoadSceneAsync(mState.SceneName);
```

# 外观模式（Facade）

![image-20241122213545480](assets/image-20241122213545480-20250209153706-u7ipv2s.png)

![image-20241122213758239](assets/image-20241122213758239-20250209153706-if1upyb.png)

![image-20241122214014157](assets/image-20241122214014157-20250209153706-e2x4duw.png)

# 单例模式

## 优点

易于访问

## 缺点

单例模式没有抽象层，难扩展

![image-20241123123945454](assets/image-20241123123945454-20250209153706-6znmdm1.png)

```c#
private static GameFacade _instance = new GameFacade();
private GameFacade() { }
public static GameFacade Instance { get { return _instance; } }
```

# 中介者模式

- 和外观模式区别，外观模式是单向的
- 对于BattleState来说是中介者模式

![image-20241123131927420](assets/image-20241123131927420-20250209153706-q1w28gv.png)

![image-20241123131943947](assets/image-20241123131943947-20250209153706-itlq7hz.png)

# 角色系统

![image-20241123135615360](assets/image-20241123135615360-20250209153706-mb7qwp5.png)

# 角色和武器（桥接模式）

将抽象和实现分离，使他们都可以独立的变化

![image-20241123164459742](assets/image-20241123164459742-20250209153706-qkq0req.png)

# 策略模式（计算伤害）

形似桥接模式，但 注重于计算方法

![image-20241124153603664](assets/image-20241124153603664-20250209153706-snrzqft.png)

# 模板方法模式

固定的一系列步骤

方便扩展，方便修改模板

**当模板的某个步骤行为很复杂才使用**

![image-20241124212209691](assets/image-20241124212209691-20250209153706-rupi1uq.png)

![image-20241124212333436](assets/image-20241124212333436-20250209153706-314d414.png)

# 工厂模式

客户想要使用车就必须创建车，客户和车就耦合在一起

![image-20241126194309851](assets/image-20241126194309851-20250209153706-tcbeop7.png)

## 简单工厂模式：不符合开闭原则

![image-20241126194609564](assets/image-20241126194609564-20250209153706-3ni7shu.png)

## 工厂方法模式

一类资源

![image-20241126195058573](assets/image-20241126195058573-20250209153706-wefbubr.png)

## 抽象工厂模式

![image-20241126200104217](assets/image-20241126200104217-20250209153706-o8l0z6w.png)

# 建造者模式

模式组成

- Product类
- Builder接口
- Director类

![image-20241127161523961](assets/image-20241127161523961-20250209153706-nka5e6c.png)

![image-20241127162320669](assets/image-20241127162320669-20250209153706-gnggqla.png)

# 享元模式（对象池类似 ）

共享对象

![image-20241127224259420](assets/image-20241127224259420-20250209153706-nak0poy.png)

以上的基础属性基本不会改变，每次实例化对象都会有大量士兵拥有相同的属性

![image-20241127224715238](assets/image-20241127224715238-20250209153706-i8avscq.png)

类图

- builder类就是client
- CharacterAttrFactory是FlyweihtFactory
- SoldierAttr相当于ConcreteFlyweight
- baseAttr是Flyweight，**是共享属性对象**，从工厂获得

baseAttr由工厂产生，仅有一份，工厂由manager维护一个单例，应该是facade模式

![image-20241202154228099](assets/image-20241202154228099-20250209153706-ynklg62.png)

# 组合模式

处理递归的树形结构

unity的GameObject

![image-20241203215039837](assets/image-20241203215039837-20250209153706-18p4plz.png)

# 命令模式

![image-20241210201938605](assets/image-20241210201938605-20250209153706-l5gd7w2.png)

![image-20241210210234027](assets/image-20241210210234027-20250209153706-5ehlta9.png)

# 责任链模式

![image-20241217092058313](assets/image-20241217092058313-20250209153706-fgy7oj4.png)

## 这是没有使用责任链模式的代码

- 对client代码存在修改，不符合开闭原则
  - 使用责任链模式避免了switch语句的使用

```c#
char problem = 'a';
switch (problem)
{
    case 'a':
        new DMHandleA().Handle();
        break;
    case 'b':
        new DMHandleB().Handle();
        break;
    default:
        break;
}
```

# <span id="20250209153706-032pxfl" style="display: none;"></span>观察者模式（订阅者模式）

![image-20241217205942924](assets/image-20241217205942924-20250209153706-8cja4v8.png)

![image-20241217210512848](assets/image-20241217210512848-20250209153706-uk8l7hd.png)

# 备忘录模式

统一数据管理

![image-20241219215416773](assets/image-20241219215416773-20250209153706-9ibozs2.png)

![image-20241219215327141](assets/image-20241219215327141-20250209153706-h3mkxtm.png)

# 访问者模式

![image-20241220162548994](assets/image-20241220162548994-20250209153706-aguyj1z.png)

![image-20241220171902221](assets/image-20241220171902221-20250209153706-tb9sk18.png)

- CharacterSystem 是IShapeController
- ICharacter是IShap
- ISoldier和IEnemy是 Sphere等，也可以是ISoldier下的具体类型实现RunVisitor，看实际的需求
- ICharactorVisitor是IShapeVisitor

# 适配器模式

![image-20241223155255746](assets/image-20241223155255746-20250209153706-w36hktq.png)

## 适用场景

### 俘虏系统

SoldierCaptive作为适配器

![image-20241223163103304](assets/image-20241223163103304-20250209153706-xmz2ktd.png)

### 宠物系统

# 代理模式

- 代理模式可以在不改变一个类的情况下实现一个新的类
- 通过一个代理对象来代表原始对象

![image-20241223203103754](assets/image-20241223203103754-20250209153706-7gmtaqy.png)

![image-20241223203607386](assets/image-20241223203607386-20250209153706-rj176dc.png)

# 装饰模式

对一个或者多个属性产生附加值

## buff机制

# 迭代器模式、原型模式、解释器模式

# Navigation太老了可能要弃用

# 踩坑指南

## 测试的时候记得打开禁用，不然Find方法会找不到

## 空指针异常一般是对象.方法中的对象是空的
