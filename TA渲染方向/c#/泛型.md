# 泛型

# 一、泛型类、接口、函数

![image](assets/image-20250326210358-l7nnqcd.png)

![image](assets/image-20250326211207-0uc1b9o.png)![image](assets/image-20250326211400-v6h5ab1.png)

## 泛型的默认值：default(T)

```csharp
public class A<T,X>
{
    public void Func<K>(K val)
    {

    }
}
```

## 泛型类中的泛型方法

![image](assets/image-20250326211809-823ehvp.png)

## 泛型方法的T可以省略不写

![image](assets/image-20250326211943-dq7zjku.png)

## 继承泛型类可以选择指定类型，也可不指定

```csharp
public class A<T,X>
{
    
}
public class B<T, X,Y>:A <T,X>
{

}
public class C : A<int, string>
{

}
```

## 举例

![image](assets/image-20250326212220-aa99dot.png)

## 总结

![image](assets/image-20250326212342-qgp4sik.png)

# 二、泛型约束（6种）

![image](assets/image-20250326212919-z5seckd.png)

## new

- 所有的值类型都有无参构造函数
- 不能使用抽象类

![image](assets/image-20250328103116-ivy68rk.png)

![image](assets/image-20250328103155-zjjryhb.png)

## 类名

类本身和他的派生

![image](assets/image-20250328104158-immkf61.png)

## 接口

接口的的派生，接口本身也不报错，但是无法new

## 另一个泛型约束

要么T是U的派生，要么一样

![image](assets/image-20250328132618-jnfebzb.png)

## 约束的组合使用

![image](assets/image-20250328132827-be8uniw.png)

## 多个泛型有约束

![image](assets/image-20250328132938-w6xqyb1.png)

‍
